<h4 id="location匹配规则">location匹配规则</h4>
<h5 id="语法规则">语法规则</h5>
<blockquote>
  <table>
    <tbody>
      <tr>
        <td>location [=</td>
        <td>~</td>
        <td>~*</td>
        <td>^~] /uri/ { … }</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>location = /uri</td>
      <td>= 表示精确匹配，只有完全匹配上才能生效</td>
    </tr>
    <tr>
      <td>location ^~ /uri</td>
      <td>^~ 开头对URL路径进行前缀匹配，并且在正则之前。</td>
    </tr>
    <tr>
      <td>location ~ pattern</td>
      <td>开头表示区分大小写的正则匹配</td>
    </tr>
    <tr>
      <td>location ~* pattern</td>
      <td>开头表示不区分大小写的正则匹配</td>
    </tr>
    <tr>
      <td>location /uri</td>
      <td>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后</td>
    </tr>
    <tr>
      <td>location /</td>
      <td>通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default</td>
    </tr>
  </tbody>
</table>

<p>前缀匹配时，Nginx 不对 url 做编码，因此请求为 /static/20%/aa，可以被规则 ^~ /static/ /aa 匹配到（注意是空格）</p>

<p>多个 location 配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）:</p>
<ul>
  <li>首先精确匹配 <code class="highlighter-rouge">=</code></li>
  <li>其次前缀匹配 <code class="highlighter-rouge">^~</code></li>
  <li>其次是按文件中顺序的正则匹配</li>
  <li>然后匹配不带任何修饰的前缀匹配。</li>
  <li>最后是交给 <code class="highlighter-rouge">/</code> 通用匹配</li>
  <li>当有匹配成功时候，停止匹配，按当前匹配规则处理请求</li>
</ul>

<p>注意：前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：<code class="highlighter-rouge">location /dir01</code> 与 <code class="highlighter-rouge">location /dir01/dir02</code>，如有请求 <code class="highlighter-rouge">http://localhost/dir01/dir02/file</code> 将最终匹配到 <code class="highlighter-rouge">location /dir01/dir02</code></p>

<h4 id="rewrite-语法">rewrite 语法</h4>
<ul>
  <li>last – 基本上都用这个 Flag（rewrite匹配后，会再次发起一个请求，只会对location里的规则再次匹配）</li>
  <li>break – 中止 Rewirte，不再继续匹配（rewrite匹配后，不会发起请求，也不会匹配后面的规则）</li>
  <li>redirect – 返回临时重定向的 HTTP 状态 302</li>
  <li>permanent – 返回永久重定向的 HTTP 状态 301</li>
</ul>

<h4 id="if-是邪恶的">if 是邪恶的</h4>
<p>当在 location 区块中使用 if 指令的时候会有一些问题, 在某些情况下它并不按照你的预期运行而是做一些完全不同的事情。而在另一些情况下他甚至会出现段错误。一般来说避免使用 if 指令是个好主意。</p>

<p>在 location 区块里 if 指令下唯一 100% 安全的指令应该只有:</p>

<blockquote>
  <p>return …; rewrite … last;</p>
</blockquote>

<p>除此以外的指令都可能导致不可预期的行为, 包括诡异的发出段错误信号 (SIGSEGV)。</p>

<h4 id="nginx-静态文件服务">Nginx 静态文件服务</h4>
<p>我们先来看看最简单的本地静态文件服务配置示例：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
	<span class="kn">listen</span>       <span class="mi">80</span><span class="p">;</span>
	<span class="kn">server_name</span> <span class="s">www.test.com</span><span class="p">;</span>
	<span class="kn">charset</span> <span class="s">utf-8</span><span class="p">;</span>
	<span class="kn">root</span>   <span class="n">/data/www.test.com</span><span class="p">;</span>
	<span class="kn">index</span>  <span class="s">index.html</span> <span class="s">index.htm</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>就这些？恩，就这些！如果只是提供简单的对外静态文件，它真的就可以用了。可是他不完美，远远没有发挥 Nginx 的半成功力，为什么这么说呢，看看下面的配置吧，为了大家看着方便，我们把每一项的作用都做了注释。</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">http</span> <span class="p">{</span>
    <span class="c1"># 这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，
</span>    <span class="c1"># 建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。
</span>    <span class="kn">open_file_cache</span> <span class="s">max=204800</span> <span class="s">inactive=20s</span><span class="p">;</span>

    <span class="c1"># open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，
</span>    <span class="c1"># 如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个
</span>    <span class="c1"># 文件在inactive 时间内一次没被使用，它将被移除。
</span>    <span class="kn">open_file_cache_min_uses</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1"># 这个是指多长时间检查一次缓存的有效信息
</span>    <span class="kn">open_file_cache_valid</span> <span class="s">30s</span><span class="p">;</span>

    <span class="c1"># 默认情况下，Nginx的gzip压缩是关闭的， gzip压缩功能就是可以让你节省不
</span>    <span class="c1"># 少带宽，但是会增加服务器CPU的开销哦，Nginx默认只对text/html进行压缩 ，
</span>    <span class="c1"># 如果要对html之外的内容进行压缩传输，我们需要手动来设置。
</span>    <span class="kn">gzip</span> <span class="no">on</span><span class="p">;</span>
    <span class="kn">gzip_min_length</span> <span class="mi">1k</span><span class="p">;</span>
    <span class="kn">gzip_buffers</span> <span class="mi">4</span> <span class="mi">16k</span><span class="p">;</span>
    <span class="kn">gzip_http_version</span> <span class="mi">1</span><span class="s">.0</span><span class="p">;</span>
    <span class="kn">gzip_comp_level</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kn">gzip_types</span> <span class="nc">text/plain</span> <span class="nc">application/x-javascript</span> <span class="nc">text/css</span> <span class="nc">application/xml</span><span class="p">;</span>

    <span class="kn">server</span> <span class="p">{</span>
       <span class="kn">listen</span>       <span class="mi">80</span><span class="p">;</span>
       <span class="kn">server_name</span> <span class="s">www.test.com</span><span class="p">;</span>
       <span class="kn">charset</span> <span class="s">utf-8</span><span class="p">;</span>
       <span class="kn">root</span>   <span class="n">/data/www.test.com</span><span class="p">;</span>
       <span class="kn">index</span>  <span class="s">index.html</span> <span class="s">index.htm</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们都知道，应用程序和网站一样，其性能关乎生存。但如何使你的应用程序或者网站性能更好，并没有一个明确的答案。代码质量和架构是其中的一个原因，但是在很多例子中我们看到，你可以通过关注一些十分基础的应用内容分发技术（basic application delivery techniques），来提高终端用户的体验。其中一个例子就是实现和调整应用栈（application stack）的缓存。</p>

<h4 id="nginx-陷阱和常见错误">Nginx 陷阱和常见错误</h4>
<h5 id="chmod-777">chmod 777</h5>
<p>永远不要 使用 777，这可能是一个漂亮的数字，有时候可以懒惰的解决权限问题， 但是它同样也表示你没有线索去解决权限问题，你只是在碰运气。 你应该检查整个路径的权限，并思考发生了什么事情。
要轻松的显示一个路径的所有权限，你可以使用：</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namei -om /path/to/check
</code></pre></div></div>

<h5 id="用-if-判断-server-name">用 if 判断 Server Name</h5>
<p>糟糕的配置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">server_name</span> <span class="s">example.com</span> <span class="s">*.example.com</span><span class="p">;</span>
        <span class="kn">if</span> <span class="s">(</span><span class="nv">$host</span> <span class="p">~</span><span class="sr">*</span> <span class="s">^www</span><span class="err">\</span><span class="s">.(.+))</span> <span class="p">{</span>
            <span class="kn">set</span> <span class="nv">$raw_domain</span> <span class="nv">$1</span><span class="p">;</span>
            <span class="kn">rewrite</span> <span class="s">^/(.*)</span>$ <span class="nv">$raw_domain</span><span class="n">/</span><span class="nv">$1</span> <span class="s">permanent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1"># [...]
</span>    <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>这个配置有三个问题。首先是 if 的使用, 为啥它这么糟糕呢? 你有阅读邪恶的 if 指令吗? 当 Nginx 收到无论来自哪个子域名的何种请求, 不管域名是 www.example.com 还是 example.com，这个 if 指令 总是 会被执行。 因此 Nginx 会检查 每个请求 的 Host header，这是十分低效的。 你应该避免这种情况，而是使用下面配置里面的两个 server 指令。</p>

<p>推荐的配置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">server_name</span> <span class="s">www.example.com</span><span class="p">;</span>
    <span class="kn">return</span> <span class="mi">301</span> <span class="nv">$scheme</span><span class="p">:</span><span class="n">//example.com</span><span class="nv">$request_uri</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">server</span> <span class="p">{</span>
    <span class="kn">server_name</span> <span class="s">example.com</span><span class="p">;</span>
    <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div></div>

<p>除了增强了配置的可读性，这种方法还降低了 Nginx 的处理要求；我们摆脱了不必要的 if 指令； 我们用了 $scheme 来表示 URI 中是 http 还是 https 协议，避免了硬编码。</p>

<h5 id="用-if-检查文件是否存在">用 if 检查文件是否存在</h5>
<p>使用 if 指令来判断文件是否存在是很可怕的，如果你在使用新版本的 Nginx， 你应该看看 try_files，这会让你的生活变得更轻松。
糟糕的配置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">root</span> <span class="n">/var/www/example.com</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">if</span> <span class="s">(!-f</span> <span class="nv">$request_filename</span><span class="s">)</span> <span class="p">{</span>
            <span class="kn">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>推荐的配置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">root</span> <span class="n">/var/www/example.com</span><span class="p">;</span>
    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri</span><span class="n">/</span> <span class="n">/index.html</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们不再尝试使用 if 来判断 <code class="highlighter-rouge">$uri</code> 是否存在，用 <code class="highlighter-rouge">try_files</code> 意味着你可以测试一个序列。 如果 <code class="highlighter-rouge">$uri</code> 不存在，就会尝试 <code class="highlighter-rouge">$uri/</code>，还不存在的话，在尝试一个回调 location。</p>

<h5 id="把不可控制的请求发给-php">把不可控制的请求发给 PHP</h5>
<p>很多网络上面推荐的和 PHP 相关的 Nginx 配置，都是把每一个 .php 结尾的 URI 传递给 PHP 解释器。 请注意，大部分这样的 PHP 设置都有严重的安全问题，因为它可能允许执行任意第三方代码。</p>

<p>有问题的配置通常如下：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">location</span> <span class="p">~</span><span class="sr">*</span> <span class="err">\</span><span class="s">.php</span>$ <span class="p">{</span>
    <span class="kn">fastcgi_pass</span> <span class="s">backend</span><span class="p">;</span>
    <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div></div>

<p>在这里，每一个 .php 结尾的请求，都会传递给 FastCGI 的后台处理程序。 这样做的问题是，当完整的路径未能指向文件系统里面一个确切的文件时， 默认的 PHP 配置试图是猜测你想执行的是哪个文件。</p>

<p>举个例子，如果一个请求中的 /forum/avatar/1232.jpg/file.php 文件不存在， 但是 /forum/avatar/1232.jpg 存在，那么 PHP 解释器就会取而代之， 使用 /forum/avatar/1232.jpg 来解释。如果这里面嵌入了 PHP 代码， 这段代码就会被执行起来。</p>

<p>有几个避免这种情况的选择：</p>
<ul>
  <li>在 php.ini 中设置 cgi.fix_pathinfo=0。 这会让 PHP 解释器只尝试给定的文件路径，如果没有找到这个文件就停止处理。</li>
  <li>确保 Nginx 只传递指定的 PHP 文件去执行
    <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">(file_a|file_b|file_c)</span><span class="err">\</span><span class="s">.php</span>$ <span class="p">{</span>
  <span class="kn">fastcgi_pass</span> <span class="s">backend</span><span class="p">;</span>
  <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>对于任何用户可以上传的目录，特别的关闭 PHP 文件的执行权限
    <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">location</span> <span class="n">/uploaddir</span> <span class="p">{</span>
  <span class="kn">location</span> <span class="p">~</span> <span class="sr">\.php$</span> <span class="p">{</span><span class="kn">return</span> <span class="mi">403</span><span class="p">;}</span>
  <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>使用 try_files 指令过滤出文件不存在的情况
    <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">location</span> <span class="p">~</span><span class="sr">*</span> <span class="err">\</span><span class="s">.php</span>$ <span class="p">{</span>
  <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>
  <span class="kn">fastcgi_pass</span> <span class="s">backend</span><span class="p">;</span>
  <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>使用嵌套的 location 过滤出文件不存在的情况
    <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">location</span> <span class="p">~</span><span class="sr">*</span> <span class="err">\</span><span class="s">.php</span>$ <span class="p">{</span>
  <span class="kn">location</span> <span class="p">~</span> <span class="sr">\..*/.*\.php$</span> <span class="p">{</span><span class="kn">return</span> <span class="mi">404</span><span class="p">;}</span>
  <span class="kn">fastcgi_pass</span> <span class="s">backend</span><span class="p">;</span>
  <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="丢失消失的-http-头">丢失（消失）的 HTTP 头</h5>
<p>如果你没有明确的设置 underscores_in_headers on; , Nginx 将会自动丢弃带有下划线的 HTTP 头(根据 HTTP 标准，这样做是完全正当的). 这样做是为了防止头信息映射到 CGI 变量时产生歧义，因为破折号和下划线都会被映射为下划线。</p>

<h5 id="使用主机名来解析地址">使用主机名来解析地址</h5>
<p>糟糕的配置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">upstream</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="s">http://someserver</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="nf">myhostname</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
    <span class="c1"># [...]
</span><span class="p">}</span>
</code></pre></div></div>

<p>你不应该在 listen 指令里面使用主机名。 虽然这样可能是有效的，但它会带来层出不穷的问题。 其中一个问题是，这个主机名在启动时或者服务重启中不能解析。 这会导致 Nginx 不能绑定所需的 TCP socket 而启动失败。</p>

<p>一个更安全的做法是使用主机名对应 IP 地址，而不是主机名。 这可以防止 Nginx 去查找 IP 地址，也去掉了去内部、外部解析程序的依赖。</p>
