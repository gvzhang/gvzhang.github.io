---
title: PHP生成器-yield关键字
categories:
 - PHP
 - 编程模式
tags:
 - yield
 - 协程
---

生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。

生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义函数一样, 和普通函数只返回一次不同的是, 生成器可以根据需要 yield 多次，以便生成需要迭代的值。

生成器函数的核心是yield关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。

#### 使用yield实现多任务调度
> 我决定去做的是使用协程实现多任务协作.我们要解决的问题是你想并发地运行多任务(或者“程序”）.不过我们都知道CPU在一个时刻只能运行一个任务（不考虑多核的情况）.因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 “一小会儿”.
现在你应当明白协程和任务调度之间的关系：yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器. 因此协程可以运行多个其他任务. 更进一步来说, yield还可以用来在任务和调度器之间进行通信.

既然只是让每个任务运行 “一小会儿”，总的运行时间其实是没有改变的，那么为什么要使用这种方式实现多任务调度呢？

> 阿姨：打一个菜需要1秒 小A：200个菜小B：3个菜小C：2个菜
顺序做完所有任务，需要耗时 200 + 3 + 2 = 205秒， CPU无空闲，但是用户体验却不是很好，因为显然后面的 B，C 需要等待小A 200秒的时间，这种情况下是没有IO阻塞的，但是任务A本身太耗CPU了，所以说如果单线程中出现了耗时的操作，一定会影响体验(IO操作或者是耗时的计算都属于耗时的操作，都会导致阻塞，但是这两种导致阻塞的性质是不一样的)。在所有的单线程模型中都不允许出现阻塞的情况，如果出现，那么用户体验是极差的，例如在UI编程中(QT,C# Winform)是不允许在UI线程中做耗时的操作的，否则会导致UI界面无响应。 编写Nodejs程序的时候，我们所写的代码实际上是在一个线程中执行的，所以也不允许有阻塞的操作(当然整个Nodejs框架实现异步，一定不止一个线程)。

[[1]以生活例子说明单线程与多线程][以生活例子说明单线程与多线程]
[以生活例子说明单线程与多线程]: http://www.cnblogs.com/wangqiguo/p/5470602.html
[[2] 在PHP中使用协程实现多任务调度][ 在PHP中使用协程实现多任务调度]
[ 在PHP中使用协程实现多任务调度]: http://www.laruence.com/2015/05/28/3038.html
